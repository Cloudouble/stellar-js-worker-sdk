<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Demo Page for Transaction Submission Using Horizon API :: Stellar JavaScript Worker SDK</title>
    <meta name="description" content="Demo Page for Transaction Submission Using Horizon API">
    <link rel="stylesheet" href="style.css">

    <link rel="modulepreload" href="../horizon.js?network=test">
    <script type="module">
        const params = Object.fromEntries(Array.from((new URLSearchParams(document.location.search)).entries()).filter(ent => !!ent[1])),
            queryParams = new URLSearchParams(params),
            { horizon } = await import(`../horizon.js?${queryParams}`),
            networkSelector = document.getElementById('select-network')
        for (const paramName in params) networkSelector.querySelector(`[name="${paramName}"]`).value = params[paramName]
        const networkSection = document.getElementById('network'), networkExampleCode = networkSection.querySelector('code.example')
        for (const networkProperty in horizon.network) networkSection.querySelector(`[name="${networkProperty}"]`).innerHTML = horizon.network[networkProperty]
        networkExampleCode.textContent = (params.network !== 'public' || params.endpoint || params.passphrase)
            ? `const { horizon } = await import('../horizon.js?${queryParams}')` : `const { horizon } = await import('../horizon.js')`



        //         const setupSection = sectionId => {
        //             const section = document.getElementById(sectionId), resourceTypeOptions = [],
        //                 resourceTypeSelect = section.querySelector('[name="resource-type"]'),
        //                 resourceIdInput = section.querySelector('[name="resource-id"]'),
        //                 resourceScopeSelect = section.querySelector('[name="resource-scope"]'),
        //                 addQueryParameterButton = section.querySelector('[name="add-query-parameter"]'),
        //                 queryParamsFieldset = section.querySelector('fieldset'),
        //                 resultButton = section.querySelector('form > button.get-result'),
        //                 exampleCode = section.querySelector('code.example'),
        //                 resultOutput = section.querySelector('pre'),
        //                 populateResourceScopes = () => {
        //                     const resourceType = resourceTypeSelect.value, resourceScopeOptions = [`<option value="">(optional) Select a Result Scope</option>`]
        //                     for (const scope of (horizon._types[resourceType] ?? [])) resourceScopeOptions.push(`<option>${scope}</option>`)
        //                     resourceScopeSelect.innerHTML = resourceScopeOptions.join('')
        //                 }
        //             for (const t in horizon[sectionId]) if (typeof horizon[sectionId][t] === 'function') resourceTypeOptions.push(`<option>${t}</option>`)
        //             resourceTypeSelect.innerHTML = resourceTypeOptions.join('')
        //             populateResourceScopes()
        //             resourceTypeSelect.addEventListener('change', event => populateResourceScopes())
        //             if (addQueryParameterButton) {
        //                 addQueryParameterButton.addEventListener('click', event => {
        //                     const newParameter = document.createElement('div')
        //                     newParameter.innerHTML = `<input placeholder="name"><input placeholder="value (JSON-encoded)">`
        //                     queryParamsFieldset.querySelector('small') ? queryParamsFieldset.replaceChildren(newParameter) : queryParamsFieldset.append(newParameter)
        //                     const inputs = Array.from(queryParamsFieldset.querySelectorAll('input'))
        //                     inputs[inputs.length - 2].focus()
        //                 })
        //             }
        //             let running = false, abortController, eventSource
        //             resultButton.addEventListener('click', async event => {
        //                 if (running && abortController && eventSource) {
        //                     abortController.abort()
        //                     eventSource.close()
        //                     resultButton.textContent = 'Start Listening for Results'
        //                     resultButton.classList.remove('running')
        //                     abortController = undefined
        //                     eventSource = undefined
        //                 }
        //                 running = !running
        //                 if (!running) return
        //                 const resourceType = resourceTypeSelect.value, resourceId = resourceIdInput.value || undefined,
        //                     resourceScope = resourceScopeSelect.value || undefined,
        //                     paramFields = queryParamsFieldset ? queryParamsFieldset.querySelectorAll('div') : undefined,
        //                     params = paramFields?.length
        //                         ? Object.fromEntries(Array.from(paramFields).map(f => Array.from(f.querySelectorAll('input')).map(i => i.value)).filter(f => f[0] && f[1]))
        //                         : undefined
        //                 if (params) for (const k in params) try { params[k] = JSON.parse(params[k]) } catch (e) { }
        //                 let exampleCodeContent
        //                 switch (sectionId) {
        //                     case 'get': case 'listen':
        //                         exampleCodeContent = `await horizon.${sectionId}.${resourceType}(${[resourceId, resourceScope, params].map(s => s === undefined ? "undefined" : JSON.stringify(s, null, 4)).join(', ')})`
        //                         while (exampleCodeContent.endsWith(', undefined)')) exampleCodeContent = exampleCodeContent.slice(0, -12) + ')'
        //                         if (exampleCodeContent.endsWith('(undefined)')) exampleCodeContent = exampleCodeContent.replace('(undefined)', '()')
        //                         if (sectionId === 'listen') exampleCodeContent = `const { listener, abortController, eventSource }  = ${exampleCodeContent}
        // listener.addEventListener('message', event => console.log(event.data))`
        //                         break
        //                     case 'stream':
        //                         let iteratorCode = `horizon.${sectionId}.${resourceType}(${[resourceId, resourceScope, params].map(s => s === undefined ? "undefined" : JSON.stringify(s, null, 4)).join(', ')})`
        //                         while (iteratorCode.endsWith(', undefined)')) iteratorCode = iteratorCode.slice(0, -12) + ')'
        //                         if (iteratorCode.endsWith('(undefined)')) iteratorCode = iteratorCode.replace('(undefined)', '()')
        //                         exampleCodeContent = `for await (const record of ${iteratorCode}) { 
        //     console.log(record) 
        // }`
        //                         break
        //                 }
        //                 exampleCode.textContent = exampleCodeContent
        //                 switch (sectionId) {
        //                     case 'get':
        //                         try {
        //                             resultOutput.textContent = JSON.stringify(await horizon[sectionId][resourceType](resourceId, resourceScope, params), null, 4)
        //                         } catch (e) {
        //                             resultOutput.textContent = e
        //                         }
        //                         running = false
        //                         break
        //                     case 'stream':
        //                         try {
        //                             resultButton.textContent = 'Stop Streaming Results'
        //                             resultButton.classList.add('running')
        //                             resultOutput.textContent = ''
        //                             for await (const t of horizon[sectionId][resourceType](resourceId, resourceScope, params)) {
        //                                 resultOutput.textContent = `${resultOutput.textContent}\n${JSON.stringify(t, null, 4)}`
        //                                 resultOutput.scrollTo({ top: resultOutput.scrollHeight, behavior: 'smooth' })
        //                                 if (!running) {
        //                                     resultButton.textContent = 'Start Streaming Results'
        //                                     resultButton.classList.remove('running')
        //                                     break
        //                                 }
        //                             }
        //                         } catch (e) {
        //                             resultOutput.textContent = e
        //                         }
        //                         resultButton.textContent = 'Start Streaming Results'
        //                         resultButton.classList.remove('running')
        //                         break
        //                     case 'listen':
        //                         resultButton.textContent = 'Stop Listening for Results'
        //                         resultButton.classList.add('running')
        //                         resultOutput.textContent = ''
        //                         let output
        //                         try {
        //                             output = await horizon[sectionId][resourceType](resourceId, resourceScope)
        //                             const listener = output.listener
        //                             abortController = output.abortController
        //                             eventSource = output.eventSource
        //                             listener.addEventListener('message', event => {
        //                                 resultOutput.textContent = `${resultOutput.textContent}\n${event.data}`
        //                                 resultOutput.scrollTo({ top: resultOutput.scrollHeight, behavior: 'smooth' })
        //                             })
        //                         } catch (e) {
        //                             resultOutput.textContent = `Event source creation failed for resourceType: ${resourceType}, resourceId: ${resourceId}, scope: ${resourceScope}`
        //                         }
        //                         break
        //                 }
        //             })
        //         }




        const buildSection = document.getElementById('build'), operationsFieldset = buildSection.querySelector('fieldset[name="operations"]'),
            buildButton = buildSection.querySelector('button.get-result'), buildResult = buildSection.querySelector('.result'),
            addOperationButton = buildSection.querySelector('button[name="add-operation"]'),
            operationTypes = {
                CREATE_ACCOUNT: { destination: 'account', startingBalance: 'number' },
                PAYMENT: { destination: 'account', asset: 'asset', amount: 'number' },
                PATH_PAYMENT_STRICT_RECEIVE: { sendAsset: 'asset', sendMax: 'number', destination: 'account', destAsset: 'asset', destAmount: 'number', path: 'asset[]' },
                MANAGE_SELL_OFFER: { selling: 'asset', buying: 'asset', amount: 'number', price: 'price', offerID: 'number' },
                CREATE_PASSIVE_SELL_OFFER: { selling: 'asset', buying: 'asset', amount: 'number', price: 'price' },
                SET_OPTIONS: {
                    inflationDest: 'account', clearFlags: 'number', setFlags: 'number', masterWeight: 'number', lowThreshold: 'number',
                    medThreshold: 'number', highThreshold: 'number', homeDomain: 'string', signer: 'json'
                },
                CHANGE_TRUST: { line: 'asset', limit: 'number' },
                ALLOW_TRUST: { trustor: 'account', asset: 'asset', authorize: 'number' },
                ACCOUNT_MERGE: ['account', 'into'],
                INFLATION: null,
                MANAGE_DATA: ['name', 'value'],
                BUMP_SEQUENCE: ['bump_to'],
                MANAGE_BUY_OFFER: ['amount', 'price', 'price_r', 'buying_asset_type', 'buying_asset_issuer', 'buying_asset_code',
                    'selling_asset_type', 'selling_asset_issuer', 'selling_asset_code', 'offer_id'],
                PATH_PAYMENT_STRICT_SEND: ['asset_type', 'asset_code', 'asset_issuer', 'from', 'to', 'amount', 'path',
                    'source_amount', 'destination_min', 'source_asset_type', 'source_asset_code', 'source_asset_issuer'],
                CREATE_CLAIMABLE_BALANCE: ['asset', 'amount', 'claimants'],
                CLAIM_CLAIMABLE_BALANCE: ['balance_id', 'claimant'],
                BEGIN_SPONSORING_FUTURE_RESERVES: ['sponsored_id'],
                END_SPONSORING_FUTURE_RESERVES: null,
                REVOKE_SPONSORSHIP: ['account_id', 'claimable_balance_id', 'data_account_id', 'data_name', 'offer_id',
                    'trustline_account_id', 'trustline_asset', 'signer_account_id', 'signer_key'],
                CLAWBACK: ['asset', 'from', 'amount'],
                CLAWBACK_CLAIMABLE_BALANCE: ['balance_id'],
                SET_TRUST_LINE_FLAGS: ['trustor', 'asset', 'set_flags', 'set_flags_s', 'clear_flags', 'clear_flags_s'],
                LIQUIDITY_POOL_DEPOSIT: ['liquidity_pool_id', 'reserves_max', 'min_price', 'min_price_r', 'max_price', 'max_price_r',
                    'reserves_deposited', 'shares_received'],
                LIQUIDITY_POOL_WITHDRAW: [],
                INVOKE_HOST_FUNCTION: ['function', 'parameters', 'address', 'salt', 'asset_balance_changes'],
                EXTEND_FOOTPRINT_TTL: ['extend_to'],
                RESTORE_FOOTPRINT: []
            },
            operationAttributeTypes = {
                path: ['object'],
                price_r: 'object',
                signer_weight: 'number',
                master_key_weight: 'number',
                low_threshold: 'number',
                med_threshold: 'number',
                high_threshold: 'number',
                set_flags: ['number'],
                set_flags_s: ['number'],
                clear_flags: ['number'],
                clear_flags_s: ['number'],
                authorize: 'number',
                claimants: ['object'],
                reserves_max: ['object'],
                min_price_r: 'object',
                max_price_r: 'object',
                reserves_deposited: ['object'],
                parameters: ['object'],
                asset_balance_changes: ['object'],
                extend_to: 'number'
            },
            operationTypeSelect = `<select name="type"><option value="">Select Operation Type</option>${Object.keys(operationTypes)
                .map(t => ('<option value="' + t + '">' + t + '</option>')).join('')}</select>`
        const sourceAccountField = buildSection.querySelector('[name="source_account"]'),
            sourceAccountSequenceField = buildSection.querySelector('[name="source_account_sequence"]'),
            fetchSequenceNumber = async () => sourceAccountSequenceField.value = sourceAccountField.value ? (await horizon.get.accounts(sourceAccountField.value)).sequence : ''
        sourceAccountField.addEventListener('change', event => fetchSequenceNumber())
        if (sourceAccountField.value) fetchSequenceNumber()

        addOperationButton.addEventListener('click', event => {
            const newOperation = document.createElement('div')
            newOperation.classList.add('operation')
            newOperation.innerHTML = `${operationTypeSelect}<span class="operation-attributes"></span><i title="remove operation">x</i>`
            operationsFieldset.querySelector('small') ? operationsFieldset.replaceChildren(newOperation) : operationsFieldset.append(newOperation)
            const typeSelector = newOperation.querySelector('select[name="type"]'),
                attributesInputs = newOperation.querySelector('span.operation-attributes'),
                removeButton = newOperation.querySelector('i')
            typeSelector.focus()
            const setupOperationType = () => {
                const operationType = typeSelector.value
                if (!operationType || !operationTypes[operationType]) return attributesInputs.replaceChildren()
                const operationAttributes = operationTypes[operationType]
                operationAttributes.unshift('sourceAccount')
                attributesInputs.replaceChildren()
                for (const attr of operationAttributes) {
                    const attrInput = document.createElement('input')
                    attrInput.setAttribute('name', attr)
                    if (operationAttributeTypes[attr]) {
                        if (operationAttributeTypes[attr] === 'number') {
                            attrInput.setAttribute('placeholder', attr)
                            attrInput.setAttribute('type', 'number')
                        } else {
                            attrInput.setAttribute('placeholder', `${attr} as ${JSON.stringify(operationAttributeTypes[attr])} JSON-encoded`)
                            attrInput.dataset.type = 'json'
                        }
                    } else {
                        attrInput.setAttribute('placeholder', attr)
                    }
                    attributesInputs.append(attrInput)
                }
            }
            setupOperationType()
            typeSelector.addEventListener('change', event => setupOperationType())
            removeButton.addEventListener('click', event => {
                newOperation.remove()
            })
        })
        buildButton.addEventListener('click', event => {
            const transactionObject = {
                sourceAccount: {
                    ed25519: Array.from(horizon.utils.addressToPublicKeyBytes(sourceAccountField.value)[0]),
                    type: 'KEY_TYPE_ED25519'
                },
                fee: parseInt(buildSection.querySelector('[name="max_fee"]').value) || 0,
                seqNum: sourceAccountSequenceField.value ? parseInt(sourceAccountSequenceField.value) : null,
                cond: {},
                memo: { type: 'MEMO_NONE' },
                operations: [],
                ext: { v: 0 }
            }, memoContent = buildSection.querySelector('[name="memo_content"]').value
            if (memoContent) {
                transactionObject.memo.type = buildSection.querySelector('[name="memo_type"]').value || 'MEMO_NONE'
                switch (transactionObject.memo.type) {
                    case 'MEMO_TEXT':
                        transactionObject.memo.text = memoContent
                        break
                    case 'MEMO_ID':
                        transactionObject.memo.id = memoContent
                        break
                    case 'MEMO_HASH':
                    case 'MEMO_RETURN':
                        let hash
                        try { hash = JSON.parse(memoContent) } catch (e) { }
                        if (!Array.isArray(hash)) throw new Error('hash must be an array of bytes as unsigned integers')
                        transactionObject.memo[transactionObject.memo.type === 'MEMO_RETURN' ? 'retHash' : 'hash'] = hash
                }
            }


            const preconditionFieldset = buildSection.querySelector('fieldset[name="preconditions"]'), preconditionsObject = { type: 'PRECOND_NONE' }
            for (const condType of ['timeBounds', 'ledgerBounds', 'minSeqNum', 'minSeqAge', 'minSeqLedgerGap', 'extraSigners']) {
                switch (condType) {
                    case 'timeBounds': case 'ledgerBounds':
                        const boundsElement = preconditionFieldset.querySelector(`[name="${condType}"]`),
                            min = parseInt(boundsElement.querySelector('[name^="min"]').value),
                            max = parseInt(boundsElement.querySelector('[name^="max"]').value)
                        if (min || max) {
                            preconditionsObject[condType] = {}
                            if (min) preconditionsObject[condType][condType === 'timeBounds' ? 'minTime' : 'minLedger'] = min
                            if (max) preconditionsObject[condType][condType === 'timeBounds' ? 'maxTime' : 'maxLedger'] = max
                            preconditionsObject.type = condType === 'timeBounds' ? 'PRECOND_TIME' : 'PRECOND_V2'
                            if (condType === 'ledgerBounds') {
                                preconditionsObject.v2 ||= {}
                                if (preconditionsObject.timeBounds) preconditionsObject.v2.timeBounds = { ...preconditionsObject.timeBounds }
                                if (preconditionsObject.ledgerBounds) preconditionsObject.v2.ledgerBounds = { ...preconditionsObject.ledgerBounds }
                                delete preconditionsObject.timeBounds
                                delete preconditionsObject.ledgerBounds
                            }
                        }
                        break
                    case 'minSeqNum': case 'minSeqAge': case 'minSeqLedgerGap': case 'extraSigners':
                        const condValue = preconditionFieldset.querySelector(`[name="${condType}"] input`).value
                        if (!condValue) continue
                        preconditionsObject.type = 'PRECOND_V2'
                        preconditionsObject.v2 ||= {}
                        if (preconditionsObject.timeBounds) preconditionsObject.v2.timeBounds = { ...preconditionsObject.timeBounds }
                        delete preconditionsObject.timeBounds
                        switch (condType) {
                            case 'minSeqNum': case 'minSeqAge': case 'minSeqLedgerGap':
                                preconditionsObject.v2[condType] = parseInt(condValue)
                                break
                            case 'extraSigners':
                                let extraSigners
                                try { extraSigners = JSON.parse(condValue) } catch (e) { }
                                if (extraSigners) preconditionsObject.v2[condType] = extraSigners
                        }
                        break
                }
            }
            transactionObject.cond = preconditionsObject


            const operationElements = buildSection.querySelectorAll('fieldset[name="operations"] > div')
            for (const operationElement of operationElements) {
                const operationType = operationElement.querySelector('select[name="type"]').value
                if (!operationType) continue
                const operationProperty = operationType.toLowerCase().split('_').map((v, i) => i ? `${v[0].toUpperCase()}${v.slice(1)}` : v).join('') + 'Op'
                const operationObject = {
                    body: {
                        type: operationType,
                        [operationProperty]: {}
                    }
                }
                for (const operationAttributeInput of operationElement.querySelectorAll('.operation-attributes > input')) {
                    const attrName = operationAttributeInput.name, attrValue = operationAttributeInput.value
                    if (!attrValue) continue
                    if (attrName === 'sourceAccount') {
                        operationObject.sourceAccount = {
                            ed25519: Array.from(horizon.utils.addressToPublicKeyBytes(attrValue)[0]),
                            type: 'KEY_TYPE_ED25519'
                        }
                    } else if (operationAttributeInput.getAttribute('type') === 'number') {
                        operationObject.body[operationProperty][attrName] = parseInt(attrValue) ?? undefined
                    } else if (operationAttributeInput.dataset.type === 'json') {
                        try {
                            operationObject.body[operationProperty][attrName] = JSON.parse(attrValue)
                        } catch (e) {
                            console.error(`Invalid ${attrName} JSON value in ${operationObject.type} operation`, e)
                        }
                    } else {
                        operationObject.body[operationProperty][attrName] = attrValue
                    }
                }
                transactionObject.operations ||= []
                transactionObject.operations.push(operationObject)
            }
            buildResult.textContent = JSON.stringify(transactionObject, null, 4)
        })




        window.horizon = horizon
        console.log('line 378', horizon)
        // test account on test netwwork: GA5VCCBNG4SIEST6HYIW2F3KKZRHA4UZZ2XFSMZ4VRQ4MCBRHSQRRIPE

    </script>

</head>

<body>
    <header>
        <h1>Transaction Submission Test Using Horizon API</h1>
        <p>Using <a href="https://github.com/Cloudouble/stellar-js-worker-sdk">JS Worker SDK</a></p>
        <form id="select-network">
            <label>
                <small>Select Network</small>
                <select name="network">
                    <option>public</option>
                    <option>test</option>
                    <option>futurenet</option>
                    <option>custom</option>
                </select>
            </label>
            <fieldset>
                <small>Optional: only if "custom" network selected above</small>
                <input name="endpoint" placeholder="Custom Network Endpoint" type="url">
                <input name="passphrase" placeholder="Passphrase for Custom Network">
            </fieldset>
            <button type="submit">Connect to Network</button>
        </form>
    </header>
    <main>
        <section id="network">
            <h2>Network</h2>
            <p>Information about the currently selected network</p>
            <ul>
                <li>Endpoint:
                    <pre name="endpoint"></pre>
                </li>
                <li>Passphrase:
                    <pre name="passphrase"></pre>
                </li>
            </ul>
            <code class="example">Example Code</code>
        </section>
        <section id="build">
            <h2>Build</h2>
            <p>Build a Transaction to Submit</p>
            <form>
                <label>
                    <strong>Source Account</strong>
                    <input name="source_account" placeholder="Address of source account"
                        value="GA5VCCBNG4SIEST6HYIW2F3KKZRHA4UZZ2XFSMZ4VRQ4MCBRHSQRRIPE">
                </label>
                <label>
                    <strong>Sequence Number</strong>
                    <input name="source_account_sequence" placeholder="Auto-populated source account sequence number"
                        readonly>
                </label>
                <label>
                    <strong>Max Fee</strong>
                    <input name="max_fee" type="number" placeholder="Max fee (in stroops)" value="100">
                </label>
                <label>
                    <strong>Memo</strong>
                    <fieldset name="memo">
                        <select name="memo_type">
                            <option value="">No Memo</option>
                            <option value="MEMO_TEXT">Text Memo</option>
                            <option value="MEMO_ID">ID Memo</option>
                            <option value="MEMO_HASH">Hash Memo</option>
                            <option value="MEMO_RETURN">Return Memo</option>
                        </select>
                        <input name="memo_content" placeholder="memo content">
                    </fieldset>
                </label>
                <label>
                    <strong>Preconditions</strong>
                    <fieldset name="preconditions">
                        <div name="timeBounds">
                            <strong>timeBounds</strong><input name="minTime" placeholder="minTime"><input name="maxTime"
                                placeholder="maxTime">
                        </div>
                        <div name="ledgerBounds">
                            <strong>ledgerBounds</strong><input name="minLedger" type="number"
                                placeholder="minLedger"><input name="maxLedger" type="number" placeholder="maxLedger">
                        </div>
                        <div name="minSeqNum"><strong>minSeqNum</strong><input placeholder="string value"></div>
                        <div name="minSeqAge"><strong>minSeqAge</strong><input type="number" placeholder="minSeqAge">
                        </div>
                        <div name="minSeqLedgerGap">
                            <strong>minSeqLedgerGap</strong><input type="number" placeholder="minSeqLedgerGap">
                        </div>
                        <div name="extraSigners"><strong>extraSigners</strong><input
                                placeholder="array of strings (JSON encoded)" data-type="json"></div>
                    </fieldset>
                </label>
                <label>
                    <strong>Operations</strong><button type="button" name="add-operation"
                        title="click to add an operation">+</button>
                    <fieldset name="operations"><small>No operations added.</small></fieldset>
                </label>
                <button type="button" class="get-result">Build</button>
            </form>
            <!-- <code class="example">Example Code</code> -->
            <pre class="result">Transaction Object</pre>
        </section>
        <section id="envelope">
            <h2>Envelope</h2>
            <p>View the transaction envelope in XDR format</p>

        </section>
        <section id="sign">
            <h2>Sign</h2>
            <p>Sign the transaction</p>

        </section>
        <section id="submit">
            <h2>Submit</h2>
            <p>Submit the transaction</p>

        </section>

    </main>
    <footer>
        <p>Created as the deliverable for Milestone Two of Stellar JavaScript Worker SDK</p>
    </footer>

</body>

</html>